// Code generated by go-enum DO NOT EDIT.
// Version: -
// Revision: -
// Build Date: -
// Built By: -

package oauth

import (
	"database/sql/driver"
	"errors"
	"fmt"
	"strings"
)

const (
	// RegisterFieldUsername is a RegisterField of type username.
	RegisterFieldUsername RegisterField = "username"
	// RegisterFieldEmail is a RegisterField of type email.
	RegisterFieldEmail RegisterField = "email"
	// RegisterFieldPhone is a RegisterField of type phone.
	RegisterFieldPhone RegisterField = "phone"
	// RegisterFieldPassword is a RegisterField of type password.
	RegisterFieldPassword RegisterField = "password"
	// RegisterFieldCaptcha is a RegisterField of type captcha.
	RegisterFieldCaptcha RegisterField = "captcha"
)

var ErrInvalidRegisterField = fmt.Errorf("not a valid RegisterField, try [%s]", strings.Join(_RegisterFieldNames, ", "))

var _RegisterFieldNames = []string{
	string(RegisterFieldUsername),
	string(RegisterFieldEmail),
	string(RegisterFieldPhone),
	string(RegisterFieldPassword),
	string(RegisterFieldCaptcha),
}

// RegisterFieldNames returns a list of possible string values of RegisterField.
func RegisterFieldNames() []string {
	tmp := make([]string, len(_RegisterFieldNames))
	copy(tmp, _RegisterFieldNames)
	return tmp
}

// RegisterFieldValues returns a list of the values for RegisterField
func RegisterFieldValues() []RegisterField {
	return []RegisterField{
		RegisterFieldUsername,
		RegisterFieldEmail,
		RegisterFieldPhone,
		RegisterFieldPassword,
		RegisterFieldCaptcha,
	}
}

// String implements the Stringer interface.
func (x RegisterField) String() string {
	return string(x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x RegisterField) IsValid() bool {
	_, err := ParseRegisterField(string(x))
	return err == nil
}

var _RegisterFieldValue = map[string]RegisterField{
	"username": RegisterFieldUsername,
	"email":    RegisterFieldEmail,
	"phone":    RegisterFieldPhone,
	"password": RegisterFieldPassword,
	"captcha":  RegisterFieldCaptcha,
}

// ParseRegisterField attempts to convert a string to a RegisterField.
func ParseRegisterField(name string) (RegisterField, error) {
	if x, ok := _RegisterFieldValue[name]; ok {
		return x, nil
	}
	return RegisterField(""), fmt.Errorf("%s is %w", name, ErrInvalidRegisterField)
}

var errRegisterFieldNilPtr = errors.New("value pointer is nil") // one per type for package clashes

// Scan implements the Scanner interface.
func (x *RegisterField) Scan(value interface{}) (err error) {
	if value == nil {
		*x = RegisterField("")
		return
	}

	// A wider range of scannable types.
	// driver.Value values at the top of the list for expediency
	switch v := value.(type) {
	case string:
		*x, err = ParseRegisterField(v)
	case []byte:
		*x, err = ParseRegisterField(string(v))
	case RegisterField:
		*x = v
	case *RegisterField:
		if v == nil {
			return errRegisterFieldNilPtr
		}
		*x = *v
	case *string:
		if v == nil {
			return errRegisterFieldNilPtr
		}
		*x, err = ParseRegisterField(*v)
	default:
		return errors.New("invalid type for RegisterField")
	}

	return
}

// Value implements the driver Valuer interface.
func (x RegisterField) Value() (driver.Value, error) {
	return x.String(), nil
}

// Set implements the Golang flag.Value interface func.
func (x *RegisterField) Set(val string) error {
	v, err := ParseRegisterField(val)
	*x = v
	return err
}

// Get implements the Golang flag.Getter interface func.
func (x *RegisterField) Get() interface{} {
	return *x
}

// Type implements the github.com/spf13/pFlag Value interface.
func (x *RegisterField) Type() string {
	return "RegisterField"
}

type NullRegisterField struct {
	RegisterField RegisterField
	Valid         bool
}

func NewNullRegisterField(val interface{}) (x NullRegisterField) {
	err := x.Scan(val) // yes, we ignore this error, it will just be an invalid value.
	_ = err            // make any errcheck linters happy
	return
}

// Scan implements the Scanner interface.
func (x *NullRegisterField) Scan(value interface{}) (err error) {
	if value == nil {
		x.RegisterField, x.Valid = RegisterField(""), false
		return
	}

	err = x.RegisterField.Scan(value)
	x.Valid = (err == nil)
	return
}

// Value implements the driver Valuer interface.
func (x NullRegisterField) Value() (driver.Value, error) {
	if !x.Valid {
		return nil, nil
	}
	// driver.Value accepts int64 for int values.
	return string(x.RegisterField), nil
}

type NullRegisterFieldStr struct {
	NullRegisterField
}

func NewNullRegisterFieldStr(val interface{}) (x NullRegisterFieldStr) {
	x.Scan(val) // yes, we ignore this error, it will just be an invalid value.
	return
}

// Value implements the driver Valuer interface.
func (x NullRegisterFieldStr) Value() (driver.Value, error) {
	if !x.Valid {
		return nil, nil
	}
	return x.RegisterField.String(), nil
}

const (
	// SignInMethodCode is a SignInMethod of type code.
	SignInMethodCode SignInMethod = "code"
	// SignInMethodPassword is a SignInMethod of type password.
	SignInMethodPassword SignInMethod = "password"
)

var ErrInvalidSignInMethod = fmt.Errorf("not a valid SignInMethod, try [%s]", strings.Join(_SignInMethodNames, ", "))

var _SignInMethodNames = []string{
	string(SignInMethodCode),
	string(SignInMethodPassword),
}

// SignInMethodNames returns a list of possible string values of SignInMethod.
func SignInMethodNames() []string {
	tmp := make([]string, len(_SignInMethodNames))
	copy(tmp, _SignInMethodNames)
	return tmp
}

// SignInMethodValues returns a list of the values for SignInMethod
func SignInMethodValues() []SignInMethod {
	return []SignInMethod{
		SignInMethodCode,
		SignInMethodPassword,
	}
}

// String implements the Stringer interface.
func (x SignInMethod) String() string {
	return string(x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x SignInMethod) IsValid() bool {
	_, err := ParseSignInMethod(string(x))
	return err == nil
}

var _SignInMethodValue = map[string]SignInMethod{
	"code":     SignInMethodCode,
	"password": SignInMethodPassword,
}

// ParseSignInMethod attempts to convert a string to a SignInMethod.
func ParseSignInMethod(name string) (SignInMethod, error) {
	if x, ok := _SignInMethodValue[name]; ok {
		return x, nil
	}
	return SignInMethod(""), fmt.Errorf("%s is %w", name, ErrInvalidSignInMethod)
}

var errSignInMethodNilPtr = errors.New("value pointer is nil") // one per type for package clashes

// Scan implements the Scanner interface.
func (x *SignInMethod) Scan(value interface{}) (err error) {
	if value == nil {
		*x = SignInMethod("")
		return
	}

	// A wider range of scannable types.
	// driver.Value values at the top of the list for expediency
	switch v := value.(type) {
	case string:
		*x, err = ParseSignInMethod(v)
	case []byte:
		*x, err = ParseSignInMethod(string(v))
	case SignInMethod:
		*x = v
	case *SignInMethod:
		if v == nil {
			return errSignInMethodNilPtr
		}
		*x = *v
	case *string:
		if v == nil {
			return errSignInMethodNilPtr
		}
		*x, err = ParseSignInMethod(*v)
	default:
		return errors.New("invalid type for SignInMethod")
	}

	return
}

// Value implements the driver Valuer interface.
func (x SignInMethod) Value() (driver.Value, error) {
	return x.String(), nil
}

// Set implements the Golang flag.Value interface func.
func (x *SignInMethod) Set(val string) error {
	v, err := ParseSignInMethod(val)
	*x = v
	return err
}

// Get implements the Golang flag.Getter interface func.
func (x *SignInMethod) Get() interface{} {
	return *x
}

// Type implements the github.com/spf13/pFlag Value interface.
func (x *SignInMethod) Type() string {
	return "SignInMethod"
}

type NullSignInMethod struct {
	SignInMethod SignInMethod
	Valid        bool
}

func NewNullSignInMethod(val interface{}) (x NullSignInMethod) {
	err := x.Scan(val) // yes, we ignore this error, it will just be an invalid value.
	_ = err            // make any errcheck linters happy
	return
}

// Scan implements the Scanner interface.
func (x *NullSignInMethod) Scan(value interface{}) (err error) {
	if value == nil {
		x.SignInMethod, x.Valid = SignInMethod(""), false
		return
	}

	err = x.SignInMethod.Scan(value)
	x.Valid = (err == nil)
	return
}

// Value implements the driver Valuer interface.
func (x NullSignInMethod) Value() (driver.Value, error) {
	if !x.Valid {
		return nil, nil
	}
	// driver.Value accepts int64 for int values.
	return string(x.SignInMethod), nil
}

type NullSignInMethodStr struct {
	NullSignInMethod
}

func NewNullSignInMethodStr(val interface{}) (x NullSignInMethodStr) {
	x.Scan(val) // yes, we ignore this error, it will just be an invalid value.
	return
}

// Value implements the driver Valuer interface.
func (x NullSignInMethodStr) Value() (driver.Value, error) {
	if !x.Valid {
		return nil, nil
	}
	return x.SignInMethod.String(), nil
}
