// Code generated by go-enum DO NOT EDIT.
// Version: -
// Revision: -
// Build Date: -
// Built By: -

package consts

import (
	"database/sql/driver"
	"errors"
	"fmt"
	"strings"
)

const (
	// GenderMale is a Gender of type male.
	GenderMale Gender = "male"
	// GenderFemale is a Gender of type female.
	GenderFemale Gender = "female"
	// GenderUnknown is a Gender of type unknown.
	GenderUnknown Gender = ""
)

var ErrInvalidGender = fmt.Errorf("not a valid Gender, try [%s]", strings.Join(_GenderNames, ", "))

var _GenderNames = []string{
	string(GenderMale),
	string(GenderFemale),
	string(GenderUnknown),
}

// GenderNames returns a list of possible string values of Gender.
func GenderNames() []string {
	tmp := make([]string, len(_GenderNames))
	copy(tmp, _GenderNames)
	return tmp
}

// GenderValues returns a list of the values for Gender
func GenderValues() []Gender {
	return []Gender{
		GenderMale,
		GenderFemale,
		GenderUnknown,
	}
}

// String implements the Stringer interface.
func (x Gender) String() string {
	return string(x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x Gender) IsValid() bool {
	_, err := ParseGender(string(x))
	return err == nil
}

var _GenderValue = map[string]Gender{
	"male":   GenderMale,
	"female": GenderFemale,
	"":       GenderUnknown,
}

// ParseGender attempts to convert a string to a Gender.
func ParseGender(name string) (Gender, error) {
	if x, ok := _GenderValue[name]; ok {
		return x, nil
	}
	return Gender(""), fmt.Errorf("%s is %w", name, ErrInvalidGender)
}

var errGenderNilPtr = errors.New("value pointer is nil") // one per type for package clashes

// Scan implements the Scanner interface.
func (x *Gender) Scan(value interface{}) (err error) {
	if value == nil {
		*x = Gender("")
		return
	}

	// A wider range of scannable types.
	// driver.Value values at the top of the list for expediency
	switch v := value.(type) {
	case string:
		*x, err = ParseGender(v)
	case []byte:
		*x, err = ParseGender(string(v))
	case Gender:
		*x = v
	case *Gender:
		if v == nil {
			return errGenderNilPtr
		}
		*x = *v
	case *string:
		if v == nil {
			return errGenderNilPtr
		}
		*x, err = ParseGender(*v)
	default:
		return errors.New("invalid type for Gender")
	}

	return
}

// Value implements the driver Valuer interface.
func (x Gender) Value() (driver.Value, error) {
	return x.String(), nil
}

// Set implements the Golang flag.Value interface func.
func (x *Gender) Set(val string) error {
	v, err := ParseGender(val)
	*x = v
	return err
}

// Get implements the Golang flag.Getter interface func.
func (x *Gender) Get() interface{} {
	return *x
}

// Type implements the github.com/spf13/pFlag Value interface.
func (x *Gender) Type() string {
	return "Gender"
}

type NullGender struct {
	Gender Gender
	Valid  bool
}

func NewNullGender(val interface{}) (x NullGender) {
	err := x.Scan(val) // yes, we ignore this error, it will just be an invalid value.
	_ = err            // make any errcheck linters happy
	return
}

// Scan implements the Scanner interface.
func (x *NullGender) Scan(value interface{}) (err error) {
	if value == nil {
		x.Gender, x.Valid = Gender(""), false
		return
	}

	err = x.Gender.Scan(value)
	x.Valid = (err == nil)
	return
}

// Value implements the driver Valuer interface.
func (x NullGender) Value() (driver.Value, error) {
	if !x.Valid {
		return nil, nil
	}
	// driver.Value accepts int64 for int values.
	return string(x.Gender), nil
}

type NullGenderStr struct {
	NullGender
}

func NewNullGenderStr(val interface{}) (x NullGenderStr) {
	x.Scan(val) // yes, we ignore this error, it will just be an invalid value.
	return
}

// Value implements the driver Valuer interface.
func (x NullGenderStr) Value() (driver.Value, error) {
	if !x.Valid {
		return nil, nil
	}
	return x.Gender.String(), nil
}

const (
	// IDCardTypeIdCard is a IDCardType of type id_card.
	IDCardTypeIdCard IDCardType = "id_card"
	// IDCardTypePassport is a IDCardType of type passport.
	IDCardTypePassport IDCardType = "passport"
	// IDCardTypeUnknown is a IDCardType of type unknown.
	IDCardTypeUnknown IDCardType = ""
)

var ErrInvalidIDCardType = fmt.Errorf("not a valid IDCardType, try [%s]", strings.Join(_IDCardTypeNames, ", "))

var _IDCardTypeNames = []string{
	string(IDCardTypeIdCard),
	string(IDCardTypePassport),
	string(IDCardTypeUnknown),
}

// IDCardTypeNames returns a list of possible string values of IDCardType.
func IDCardTypeNames() []string {
	tmp := make([]string, len(_IDCardTypeNames))
	copy(tmp, _IDCardTypeNames)
	return tmp
}

// IDCardTypeValues returns a list of the values for IDCardType
func IDCardTypeValues() []IDCardType {
	return []IDCardType{
		IDCardTypeIdCard,
		IDCardTypePassport,
		IDCardTypeUnknown,
	}
}

// String implements the Stringer interface.
func (x IDCardType) String() string {
	return string(x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x IDCardType) IsValid() bool {
	_, err := ParseIDCardType(string(x))
	return err == nil
}

var _IDCardTypeValue = map[string]IDCardType{
	"id_card":  IDCardTypeIdCard,
	"passport": IDCardTypePassport,
	"":         IDCardTypeUnknown,
}

// ParseIDCardType attempts to convert a string to a IDCardType.
func ParseIDCardType(name string) (IDCardType, error) {
	if x, ok := _IDCardTypeValue[name]; ok {
		return x, nil
	}
	return IDCardType(""), fmt.Errorf("%s is %w", name, ErrInvalidIDCardType)
}

var errIDCardTypeNilPtr = errors.New("value pointer is nil") // one per type for package clashes

// Scan implements the Scanner interface.
func (x *IDCardType) Scan(value interface{}) (err error) {
	if value == nil {
		*x = IDCardType("")
		return
	}

	// A wider range of scannable types.
	// driver.Value values at the top of the list for expediency
	switch v := value.(type) {
	case string:
		*x, err = ParseIDCardType(v)
	case []byte:
		*x, err = ParseIDCardType(string(v))
	case IDCardType:
		*x = v
	case *IDCardType:
		if v == nil {
			return errIDCardTypeNilPtr
		}
		*x = *v
	case *string:
		if v == nil {
			return errIDCardTypeNilPtr
		}
		*x, err = ParseIDCardType(*v)
	default:
		return errors.New("invalid type for IDCardType")
	}

	return
}

// Value implements the driver Valuer interface.
func (x IDCardType) Value() (driver.Value, error) {
	return x.String(), nil
}

// Set implements the Golang flag.Value interface func.
func (x *IDCardType) Set(val string) error {
	v, err := ParseIDCardType(val)
	*x = v
	return err
}

// Get implements the Golang flag.Getter interface func.
func (x *IDCardType) Get() interface{} {
	return *x
}

// Type implements the github.com/spf13/pFlag Value interface.
func (x *IDCardType) Type() string {
	return "IDCardType"
}

type NullIDCardType struct {
	IDCardType IDCardType
	Valid      bool
}

func NewNullIDCardType(val interface{}) (x NullIDCardType) {
	err := x.Scan(val) // yes, we ignore this error, it will just be an invalid value.
	_ = err            // make any errcheck linters happy
	return
}

// Scan implements the Scanner interface.
func (x *NullIDCardType) Scan(value interface{}) (err error) {
	if value == nil {
		x.IDCardType, x.Valid = IDCardType(""), false
		return
	}

	err = x.IDCardType.Scan(value)
	x.Valid = (err == nil)
	return
}

// Value implements the driver Valuer interface.
func (x NullIDCardType) Value() (driver.Value, error) {
	if !x.Valid {
		return nil, nil
	}
	// driver.Value accepts int64 for int values.
	return string(x.IDCardType), nil
}

type NullIDCardTypeStr struct {
	NullIDCardType
}

func NewNullIDCardTypeStr(val interface{}) (x NullIDCardTypeStr) {
	x.Scan(val) // yes, we ignore this error, it will just be an invalid value.
	return
}

// Value implements the driver Valuer interface.
func (x NullIDCardTypeStr) Value() (driver.Value, error) {
	if !x.Valid {
		return nil, nil
	}
	return x.IDCardType.String(), nil
}
